# このリポジトリについて
このリポジトリは [低レイヤを知りたい人のためのCコンパイラ作成入門](https://www.sigbus.info/compilerbook)のCコンパイラをRustで実装したリポジトリです。  

注意  
現段階ではコンパイラと呼べるものにはなっていません。  
非常に簡単な加減算の抽象構造木までを作成できる程度です。

# 目標
このリポジトリの目標はシンプルなC言語プログラムのコンパイル(X64アセンブリ)の出力です。  
以下の点は一切考慮していないのでご注意ください。
- 最適化
- 最適なX64命令の使用
- 全C言語機能の実装

# 背景
2921年3月頃からコンパイラの仕組みを理解しようと[低レイヤを知りたい人のためのCコンパイラ作成入門](https://www.sigbus.info/compilerbook)(以下Cコンパイラ作成入門)を読み進めながら, [toy_compiler](https://github.com/senrust/toy_compiler)(第一世代Cコンパイラ)を実装していました。  
Cコンパイラ作成入門は大変分かりやすい内容ですが、   
テキストは20章以降から内容の飛躍があり、Cコンパイラ作成入門以降の内容の実装を自力で行おうとすると、   
コンパイラが以下の点を考慮した設計になっている必要があります。

1. 型情報の考慮  
型を考慮する必要があります。
型の名称・サイズの登録を行い、変数や演算がどの型であるか把握できる必要があります。
2. 変数の管理  
グローバル変数、ローカル変数の変数名とその型を登録しておく必要があります。  
3. 関数の宣言と定義  
関数の関数名 引数、 戻り値を把握できるようにする必要があります。
4. スタックフレームのサイズ
スタックフレームのサイズを把握している必要があります。

Cコンパイラ作成入門に従って実装した第一世代Cコンパイラは上記の点を考慮した設計ではない上、  
Rustの習熟も兼ねた未熟な実装であったため、  
よりC言語らしいコンパイラを作成するには、抜本的な見直しが必要となりました。  
本リポジトリはその反省を踏まえて、Cコンパイラの再実装となっております。

# アーキテクチャ
Cコンパイラの処理は以下の手順となっています。
1. トークン化
2. トークン解釈
3. 抽象構造木化
4. アセンブリ出力

また、コンパイル中にエラーが発生した場合は、
エラーが発生した箇所とその理由を表示して終了します。

## 1. トークン化
ソースファイルのコメントを除く領域をトークンに分解します。  
トークンはスペースまたは記号により分割されます。  

### トークン情報
各トークンは自身の文字列、タイプ、ソースファイル内の位置を情報として持ちます。

### トークンのタイプ
トークンは以下のタイプを持ちます。  
1. 識別子  
アルファベット、または_で始まる文字列

2. 数字
0~9で始まりる文字列。  
トークン化では有効な数字表現であるかのチェックは行いません。  
12A、0x91X、1.243.4なども有効なトークンとして扱われます。  

3. 記号
C言語で有効な記号をトークンとします。  
複数記号のトークンも存在します。(++, &&, <<=など)  

4. 文字列
'A'や"Hello world"などの引用符で囲われた領域

## 2. トークン解釈
トークンを抽象構造木を作成しやすい形(Node)に変形します。  
現段階では記号タイプのトークンにその役割ラベルを付けているだけです。

## 3. 抽象構造木化  
抽象構造木情報(型、関数、変数情報)を作成してから、
各Nodeを順番に処理することで、抽象構造木を作成します。  
途中関数の宣言や変数定義があれば初期情報を編集していきます。

### 抽象構造木
抽象構造木は木構造となっており、
抽象構造木の節点にはそのタイプ(変数、演算、関数呼び出し等)の情報と、  
その節点の型情報と必要なメンバー(変数名、値、引数等)を持っています。  
メンバーもまた抽象構造木となっています。  

### 型情報
初期状態では型情報にはプリミティブ型のみです。    
構造体の宣言やtypedefで型情報を追加できます。  
型情報はサイズ、メンバー等の情報を持っています。  
型情報テーブルは型名をキー、値を型情報としたハッシュテーブルです。  
構造体のメンバー定義や関数定義、抽象構造木の各節点に持たせる必要があることから、  
型情報の実体は1つのみで、Rcで共有しています。  

### 関数情報
宣言された関数の情報で、関数名と引数の数とその型、返り値の型の情報です。  
関数情報テーブルは関数名をキー、値を関数情報としたハッシュテーブルです。  

### 変数情報
宣言された変数の情報で、変数名とその型を情報として持ちます。
変数情報テーブルにはグローバル変数とローカル変数の2種類があります。  
グローバル変数テーブルはキーを変数名、値を変数情報とした簡単なハッシュテーブルです。  
ローカル変数テーブルはキーを変数名、値をブロックの深さとしたハッシュテーブルを持ちます。  
このハッシュテーブルから得た値をブロックの深さをインデックスとしたローカル変数ベクトルを参照することで、  
各ブロックで定義されているローカル変数のハッシュテーブルを取得できます。  
各ブロックで定義されているローカル変数のハッシュテーブルは、  
キーが変数名、値がスタックフレームからのオフセット及び型情報となっています。  
これによりローカル変数はスタックフレームのオフセットを持つことができます。  
なお、ブロックを抜けるとそのブロックのローカル変数情報は削除されます。  


## 4. アセンブリ出力
作成した抽象構造木の内容をアセンブリにします。

# ファイル構造
各ファイルには以下の役割を持たせています。
|  ファイル名  |  役割  |  詳細  |  
| ---- | ---- | ---- |
|  main.rs  |  コンパイラバイナリ  | 引数として渡されたファイルをコンパイルします |
|  lib.rs  |  コンパイラテスト  | コンパイラの結合テスト用ファイルです |
|  error.rs  |  エラー出力  | コンパイルできないソースに対するエラーを出力します |
|  tokenizer.rs  |  トークン化  | ソースのトークン化を行います |
|  interpret_token.rs  |  トークン解釈  | トークンの解釈を行います |
|  make_ast.rs  |  抽象構造木作成  | 抽象構造木作成 |
|  definition/  |  定義ファイル群  | コンパイルで使用する情報の定義ファイルディレクトリです |
|  definition/functions.rs  |  関数定義  | 関数情報の定義を行います |
|  definition/numbers.rs  |  即値定義  | 即値情報の定義を行います |
|  definition/types.rs  |  型定義  | 型情報の定義を行います |
|  definition/variables.rs  |  変数定義  | 変数情報の定義を行います |



# 謝辞
[低レイヤを知りたい人のためのCコンパイラ作成入門](https://www.sigbus.info/compilerbook)を無償で公開してくださった作者に感謝申し上げます。  
素晴らしいテキストであり、 コンパイラへの知識が非常に深まりました。


# ライセンス
MITライセンスです。自由にコピー、改変して頂いて構いません。  
少しでもお役に立ったならばスターをしていただけると嬉しいです。  
ソースファイルへのアドバイス、コメントも大歓迎です。